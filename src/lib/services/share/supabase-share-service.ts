import type { SupabaseClient } from "@supabase/supabase-js";
import type {
  ShareLinkResult,
  ShareMealData,
  TokenValidationResult,
  Task,
  Timeline,
} from "@/types";

/**
 * Row shape from Supabase timelines table
 */
interface TimelineRow {
  id: string;
  meal_id: string;
  has_conflicts: boolean;
  conflicts: unknown[];
  is_running: boolean;
  started_at: string | null;
  current_task_id: string | null;
  created_at: string;
  updated_at: string;
}

/**
 * Row shape from Supabase tasks table
 */
interface TaskRow {
  id: string;
  timeline_id: string;
  meal_id: string;
  recipe_id: string;
  instruction_id: string | null;
  title: string;
  description: string | null;
  start_time_minutes: number;
  duration_minutes: number;
  end_time_minutes: number;
  requires_oven: boolean;
  oven_temp: number | null;
  depends_on: string[];
  status: string;
  completed_at: string | null;
  notes: string | null;
  is_valid: boolean;
  validation_errors: string[];
  sort_order: number;
  created_at: string;
  updated_at: string;
}

/**
 * ShareService contract for share link operations
 */
export interface ShareService {
  /**
   * Generate a share link for a meal
   * @param mealId - The meal to share
   * @param baseUrl - Base URL for constructing share links
   * @returns The generated share link with token and expiration
   */
  generateLink(mealId: string, baseUrl: string): Promise<ShareLinkResult>;

  /**
   * Validate a share token
   * @param token - The token to validate
   * @returns Validation result with meal ID if valid
   */
  validateToken(token: string): Promise<TokenValidationResult>;

  /**
   * Get complete meal data for share link viewers
   * @param token - A valid share token
   * @returns Full meal, timeline, and task data for display
   */
  getShareData(token: string): Promise<ShareMealData | null>;

  /**
   * Revoke all share links for a meal
   * @param mealId - The meal to revoke links for
   */
  revokeLinks(mealId: string): Promise<void>;
}

/**
 * SupabaseShareService: ShareService implementation using Supabase
 *
 * Handles share link generation, validation, and data retrieval.
 * Tokens expire 24 hours after the meal's serve time.
 *
 * @example
 * ```typescript
 * const shareService = new SupabaseShareService(supabase);
 * const link = await shareService.generateLink(mealId, "https://sundaydinner.app");
 * // link.url = "https://sundaydinner.app/share/abc123..."
 * ```
 */
export class SupabaseShareService implements ShareService {
  /** Hours after serve time before link expires */
  private static readonly EXPIRATION_HOURS = 24;

  constructor(private supabase: SupabaseClient) {}

  /**
   * Generate a share link for a meal
   *
   * 1. Fetches the meal's serve time
   * 2. Calculates expiration (serve time + 24 hours)
   * 3. Inserts token into database
   * 4. Returns shareable URL
   */
  async generateLink(mealId: string, baseUrl: string): Promise<ShareLinkResult> {
    // Fetch meal to get serve time for expiration calculation
    const { data: meal, error: mealError } = await this.supabase
      .from("meals")
      .select("serve_time")
      .eq("id", mealId)
      .single();

    if (mealError || !meal) {
      throw new Error(`Meal not found: ${mealId}`);
    }

    // Calculate expiration: serve time + 24 hours
    const serveTime = new Date(meal.serve_time);
    const expiresAt = new Date(
      serveTime.getTime() + SupabaseShareService.EXPIRATION_HOURS * 60 * 60 * 1000
    );

    // Insert token (UUID generated by database default)
    const { data: token, error: insertError } = await this.supabase
      .from("meal_share_tokens")
      .insert({
        meal_id: mealId,
        expires_at: expiresAt.toISOString(),
      })
      .select("token, expires_at")
      .single();

    if (insertError || !token) {
      throw new Error(`Failed to create share token: ${insertError?.message}`);
    }

    return {
      token: token.token,
      url: `${baseUrl}/share/${token.token}`,
      expiresAt: token.expires_at,
    };
  }

  /**
   * Validate a share token
   *
   * Checks if token exists and is not expired.
   * RLS policy handles expiration check in the query.
   */
  async validateToken(token: string): Promise<TokenValidationResult> {
    // RLS policy already filters expired tokens (expires_at > now())
    const { data, error } = await this.supabase
      .from("meal_share_tokens")
      .select("token, meal_id, expires_at")
      .eq("token", token)
      .single();

    if (error || !data) {
      // RLS policy filters expired tokens, so if we get here the token
      // is either not found or expired. Return generic invalid message.
      return {
        valid: false,
        error: "not_found",
        message: "This share link is invalid or has expired",
      };
    }

    // Check if currently expired (belt and suspenders)
    const now = new Date();
    const expiresAt = new Date(data.expires_at);

    if (now > expiresAt) {
      return {
        valid: false,
        error: "expired",
        message: "This share link has expired",
      };
    }

    return {
      valid: true,
      mealId: data.meal_id,
    };
  }

  /**
   * Get complete meal data for share link viewers
   *
   * Returns everything needed to display the read-only timeline view:
   * - Basic meal info (name, serve time, status)
   * - Timeline with conflicts
   * - All tasks with current status
   * - Recipe names for display
   */
  async getShareData(token: string): Promise<ShareMealData | null> {
    // First validate the token
    const validation = await this.validateToken(token);
    if (!validation.valid || !validation.mealId) {
      return null;
    }

    const mealId = validation.mealId;

    // Fetch meal data
    const { data: mealRow, error: mealError } = await this.supabase
      .from("meals")
      .select("id, name, serve_time, guest_count, status")
      .eq("id", mealId)
      .single();

    if (mealError || !mealRow) {
      return null;
    }

    // Fetch timeline
    const { data: timelineRow } = await this.supabase
      .from("timelines")
      .select("*")
      .eq("meal_id", mealId)
      .single();

    // Fetch tasks (if timeline exists)
    let tasks: Task[] = [];
    if (timelineRow) {
      const { data: taskRows } = await this.supabase
        .from("tasks")
        .select("*")
        .eq("timeline_id", timelineRow.id)
        .order("sort_order", { ascending: true });

      if (taskRows) {
        tasks = taskRows.map((row: TaskRow) => this.taskRowToTask(row));
      }
    }

    // Fetch recipe names for display
    const { data: mealRecipes } = await this.supabase
      .from("meal_recipes")
      .select("recipe_id")
      .eq("meal_id", mealId);

    const recipeIds = mealRecipes?.map((mr) => mr.recipe_id) ?? [];
    const recipeNames: Record<string, string> = {};

    if (recipeIds.length > 0) {
      const { data: recipes } = await this.supabase
        .from("recipes")
        .select("id, name")
        .in("id", recipeIds);

      if (recipes) {
        for (const recipe of recipes) {
          recipeNames[recipe.id] = recipe.name;
        }
      }
    }

    return {
      meal: {
        id: mealRow.id,
        name: mealRow.name,
        serveTime: mealRow.serve_time,
        guestCount: (mealRow.guest_count as { total: number }).total,
        status: mealRow.status,
      },
      timeline: timelineRow ? this.timelineRowToTimeline(timelineRow as TimelineRow, tasks) : null,
      tasks,
      recipeNames,
    };
  }

  /**
   * Revoke all share links for a meal
   */
  async revokeLinks(mealId: string): Promise<void> {
    const { error } = await this.supabase
      .from("meal_share_tokens")
      .delete()
      .eq("meal_id", mealId);

    if (error) {
      throw new Error(`Failed to revoke share links: ${error.message}`);
    }
  }

  /**
   * Convert database task row to Task type
   */
  private taskRowToTask(row: TaskRow): Task {
    return {
      id: row.id,
      mealId: row.meal_id,
      recipeId: row.recipe_id,
      instructionId: row.instruction_id ?? undefined,
      title: row.title,
      description: row.description ?? undefined,
      startTimeMinutes: row.start_time_minutes,
      durationMinutes: row.duration_minutes,
      endTimeMinutes: row.end_time_minutes,
      requiresOven: row.requires_oven,
      ovenTemp: row.oven_temp ?? undefined,
      dependsOn: row.depends_on,
      status: row.status as Task["status"],
      completedAt: row.completed_at ?? undefined,
      notes: row.notes ?? undefined,
      isValid: row.is_valid,
      validationErrors: row.validation_errors,
    };
  }

  /**
   * Convert database timeline row to Timeline type
   */
  private timelineRowToTimeline(row: TimelineRow, tasks: Task[]): Timeline {
    return {
      id: row.id,
      mealId: row.meal_id,
      tasks,
      hasConflicts: row.has_conflicts,
      conflicts: row.conflicts as Timeline["conflicts"],
      isRunning: row.is_running,
      startedAt: row.started_at ?? undefined,
      currentTaskId: row.current_task_id ?? undefined,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}

/**
 * Factory function for creating share service
 */
export function createShareService(supabase: SupabaseClient): ShareService {
  return new SupabaseShareService(supabase);
}
