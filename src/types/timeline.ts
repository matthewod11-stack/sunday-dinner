import { z } from "zod";

/**
 * Task execution status during live cooking
 */
export type TaskStatus = "pending" | "in_progress" | "completed" | "skipped";

/**
 * Types of conflicts that can be detected
 */
export type ConflictType =
  | "oven_overlap" // Two tasks need oven at same time
  | "task_order" // Dependency violation (A depends on B but starts before B ends)
  | "negative_duration" // Task has negative or zero duration
  | "serve_time" // Task ends after serve time
  | "missing_dependency"; // Task depends on non-existent task

/**
 * Conflict severity level
 */
export type ConflictSeverity = "error" | "warning";

/**
 * Individual cooking task in a timeline
 *
 * Times are relative to serve time:
 * - Negative values = before serve (e.g., -120 = 2 hours before)
 * - Zero = at serve time
 * - Positive = after serve (shouldn't happen normally)
 */
export interface Task {
  /** Unique identifier (UUID from database) */
  id?: string;
  /** Reference to parent meal */
  mealId: string;
  /** Reference to source recipe */
  recipeId: string;
  /** Reference to instruction step (if applicable) */
  instructionId?: string;

  /** Task title, e.g., "Preheat oven to 350Â°F" */
  title: string;
  /** Detailed description */
  description?: string;

  /**
   * Start time in minutes relative to serve time
   * Negative = before serve, e.g., -120 = 2 hours before
   */
  startTimeMinutes: number;
  /** Duration in minutes */
  durationMinutes: number;
  /** Computed end time: startTimeMinutes + durationMinutes */
  endTimeMinutes: number;

  /** Whether this task requires the oven */
  requiresOven?: boolean;
  /** Oven temperature if required (for conflict detection) */
  ovenTemp?: number;
  /** Task IDs that must complete before this task can start */
  dependsOn?: string[];

  /** Current execution status */
  status: TaskStatus;
  /** When user marked task as completed */
  completedAt?: string;
  /** Notes added during cooking */
  notes?: string;

  /** Whether task passes validation */
  isValid?: boolean;
  /** Validation error messages */
  validationErrors?: string[];
}

/**
 * Conflict detected by the deterministic timeline validator
 */
export interface TimelineConflict {
  /** Type of conflict */
  type: ConflictType;
  /** IDs of tasks involved in the conflict */
  taskIds: string[];
  /** Human-readable description */
  description: string;
  /** Severity level */
  severity: ConflictSeverity;
}

/**
 * Full cooking timeline for a meal
 *
 * Generated by Claude, validated deterministically to prevent
 * impossible schedules (overlapping oven tasks, etc.).
 */
export interface Timeline {
  /** Unique identifier (UUID from database) */
  id?: string;
  /** Reference to parent meal */
  mealId: string;

  /** All tasks in execution order */
  tasks: Task[];

  /** Whether any conflicts were detected */
  hasConflicts: boolean;
  /** List of detected conflicts */
  conflicts: TimelineConflict[];

  /** Live execution state */
  isRunning?: boolean;
  /** When "Start Cooking" was pressed (ISO datetime) */
  startedAt?: string;
  /** Currently active task ID (the "Now" task) */
  currentTaskId?: string;

  /** Database timestamps */
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Recalculation suggestion from Claude
 *
 * Returned when user taps "I'm behind" during cooking.
 * Always returns exactly ONE suggestion with clear description.
 */
export interface RecalculationSuggestion {
  /** Which task to move */
  taskId: string;
  /** New start time (minutes relative to serve) */
  newStartTimeMinutes: number;
  /** Human-readable description of the change */
  description: string;
  /** Other tasks that will be affected */
  affectedTaskIds?: string[];
  /** Total number of tasks shifted */
  tasksShifted: number;
}

// ============================================================================
// Zod Schemas for Runtime Validation
// ============================================================================

export const TaskStatusSchema = z.enum(["pending", "in_progress", "completed", "skipped"]);

export const ConflictTypeSchema = z.enum([
  "oven_overlap",
  "task_order",
  "negative_duration",
  "serve_time",
  "missing_dependency",
]);

export const ConflictSeveritySchema = z.enum(["error", "warning"]);

export const TaskSchema = z.object({
  id: z.string().uuid().optional(),
  mealId: z.string().uuid(),
  recipeId: z.string().uuid(),
  instructionId: z.string().uuid().optional(),
  title: z.string().min(1),
  description: z.string().optional(),
  startTimeMinutes: z.number().int(), // Can be negative (before serve time)
  durationMinutes: z.number().int().positive(),
  endTimeMinutes: z.number().int(),
  requiresOven: z.boolean().optional(),
  ovenTemp: z.number().int().positive().optional(),
  dependsOn: z.array(z.string().uuid()).optional(),
  status: TaskStatusSchema,
  completedAt: z.string().datetime().optional(),
  notes: z.string().optional(),
  isValid: z.boolean().optional(),
  validationErrors: z.array(z.string()).optional(),
});

export const TimelineConflictSchema = z.object({
  type: ConflictTypeSchema,
  taskIds: z.array(z.string().uuid()),
  description: z.string(),
  severity: ConflictSeveritySchema,
});

export const TimelineSchema = z.object({
  id: z.string().uuid().optional(),
  mealId: z.string().uuid(),
  tasks: z.array(TaskSchema),
  hasConflicts: z.boolean(),
  conflicts: z.array(TimelineConflictSchema),
  isRunning: z.boolean().optional(),
  startedAt: z.string().datetime().optional(),
  currentTaskId: z.string().uuid().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

export const RecalculationSuggestionSchema = z.object({
  taskId: z.string().uuid(),
  newStartTimeMinutes: z.number().int(),
  description: z.string(),
  affectedTaskIds: z.array(z.string().uuid()).optional(),
  tasksShifted: z.number().int().nonnegative(),
});

// Type inference from schemas
export type TaskInput = z.infer<typeof TaskSchema>;
export type TimelineConflictInput = z.infer<typeof TimelineConflictSchema>;
export type TimelineInput = z.infer<typeof TimelineSchema>;
export type RecalculationSuggestionInput = z.infer<typeof RecalculationSuggestionSchema>;
